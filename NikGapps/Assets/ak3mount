#!/sbin/sh
#
# ak3mount script to perform various operations created by Nikhil Menghani
#
# inspired from topjohnwu's (@xda) magisk
# inspired from xXx's (@xda) no limits module
# inspired from osm0sis's (@xda) universal shell script functions and anykernel3 scripts (reference below)
# https://github.com/osm0sis/AnyKernel3
# inspired from opengapps installer script (reference below)
# https://github.com/opengapps/opengapps/blob/master/scripts/inc.installer.sh
#

abort_while_mounting() {
  ui_print " "
  ui_print "------------------------------------------"
  ui_print "Error: $*";
  ui_print "------------------------------------------"
  ui_print " "
  addToLog "Aborting while mounting $*"
  copyLogs_mounting;
  restore_env;
  exit 1;
}

beginswith() {
  case $2 in
    "$1"*) echo true ;;
    *) echo false ;;
  esac
}

# This is meant to copy the files safely from source to destination
CopyFile() {
  if [ -f "$1" ]; then
    mkdir -p "$(dirname "$2")"
    cp -f "$1" "$2"
  else
    addToLog "- File $1 does not exist!"
  fi
}

copyLogs_mounting() {
  CopyFile "$recoveryLog" "$logDir/logfiles/recovery.log"
  CopyFile "$nikGappsLog" "$logDir/logfiles/NikGapps.log"
  CopyFile "$system/build.prop" "$logDir/propfiles/build.prop"
  CopyFile "/vendor/etc/fstab.qcom" "$logDir/partitions/fstab.qcom"
  CopyFile "/etc/recovery.fstab" "$logDir/fstab/recovery.fstab"
  CopyFile "/sdcard/NikGapps/debloater.config" "$logDir/configfiles/debloater.config"
  CopyFile "/sdcard/NikGapps/nikgapps.config" "$logDir/configfiles/nikgapps.config"
  cd "$logDir" || return
  rm -rf "$nikGappsDir"/logs
  tar -cz -f "/tmp/$nikGappsLogFile" ./*
  mkdir -p "$nikGappsDir"/logs
  CopyFile /tmp/"$nikGappsLogFile" "$nikGappsDir"/logs/"$nikGappsLogFile"
  [ -z "$nikgapps_config_dir" ] && nikgapps_config_dir=/sdcard/NikGapps
  rm -rf "$nikgapps_config_dir"/nikgapps_logs
  mkdir -p "$nikgapps_config_dir"/nikgapps_logs
  CopyFile /tmp/"$nikGappsLogFile" "$nikgapps_config_dir"/nikgapps_logs/"$nikGappsLogFile"
  cd /
}

file_getprop() { $BB grep "^$2=" "$1" | $BB cut -d= -f2-; }

if [ ! "$(getprop 2>/dev/null)" ]; then
  getprop() {
    local propdir propfile propval
    for propdir in / /system_root /system /vendor /odm /product; do
      for propfile in default.prop build.prop; do
        test "$propval" && break 2 || propval="$(file_getprop $propdir/$propfile "$1" 2>/dev/null)"
      done
    done
    test "$propval" && echo "$propval" || echo ""
  }
elif [ ! "$(getprop ro.build.type 2>/dev/null)" ]; then
  getprop() {
    ($(which getprop) | $BB grep "$1" | $BB cut -d[ -f3 | $BB cut -d] -f1) 2>/dev/null
  }
fi

grep_cmdline() {
  local REGEX="s/^$1=//p"
  cat /proc/cmdline | tr '[:space:]' '\n' | sed -n "$REGEX" 2>/dev/null
}

# Check if the partition is mounted
is_mounted() {
  addToLog "- Checking if $1 is mounted"
  $BB mount | $BB grep -q " $1 ";
}

is_mounted_rw() {
  local mounted_rw=false
  local startswith=$(beginswith / "$1")
  test "$startswith" == "false" && part=/"$1" || part="$1"
  touch "$part"/.rw && rm "$part"/.rw && mounted_rw=true
  addToLog "- checked if $part/.rw is writable i.e. $mounted_rw ($1/.rw being original argument)"
  echo $mounted_rw
}

# Mount all the partitions
mount_all() {
  # Check A/B slot
  [ -z "$SLOT" ] || ui_print "- Current boot slot: $SLOT"
  if ! is_mounted /cache; then
    mount /cache 2>/dev/null && UMOUNT_CACHE=1
  fi
  if ! is_mounted /data; then
    ui_print "- Mounting /data"
    $BB mount /data && UMOUNT_DATA=1
  else
    addToLog "- /data already mounted!"
  fi;

  (for partition in "vendor" "product" "persist"; do
    ui_print "- Mounting /$partition"
    $BB mount -o ro -t auto "/$partition" 2>/dev/null;
  done) 2>/dev/null
  addToLog "----------------------------------------------------------------------------"
  addToLog "- Setting up mount point $ANDROID_ROOT"
  addToLog "- ANDROID_ROOT=$ANDROID_ROOT"
  setup_mountpoint "$ANDROID_ROOT"
  if ! is_mounted "$ANDROID_ROOT"; then
    mount -o ro -t auto "$ANDROID_ROOT" 2>/dev/null
  fi
  addToLog "----------------------------------------------------------------------------"
  case $ANDROID_ROOT in
    /system_root) setup_mountpoint /system;;
    /system)
      if ! is_mounted /system && ! is_mounted /system_root; then
        setup_mountpoint /system_root;
        addToLog "- mounting /system_root partition as readwrite"
        $BB mount -o rw -t auto /system_root;
      elif [ -f /system/system/build.prop ]; then
        setup_mountpoint /system_root;
        addToLog "- Moving /system to /system_root"
        $BB mount --move /system /system_root;
      fi;
      ret=$?
      addToLog "- Command Execution Status: $ret"
      if [ $ret -ne 0 ]; then
        addToLog "- Unmounting and Remounting /system as /system_root"
        (umount /system;
        umount -l /system) 2>/dev/null
        if [ -d /dev/block/mapper ]; then
          addToLog "- Device with dynamic partitions Found"
          test -e /dev/block/mapper/system || local slot=$(find_slot)
          addToLog "- Mounting /system$slot as read only"
          mount -o ro -t auto /dev/block/mapper/system"$slot" /system_root
          addToLog "- Mounting /vendor$slot as read only"
          mount -o ro -t auto /dev/block/mapper/vendor"$slot" /vendor 2>/dev/null
          addToLog "- Mounting /product$slot as read only"
          mount -o ro -t auto /dev/block/mapper/product"$slot" /product 2>/dev/null
        else
          test -e /dev/block/bootdevice/by-name/system || local slot=$(find_slot)
          (mount -o ro -t auto /dev/block/bootdevice/by-name/vendor"$slot" /vendor
          mount -o ro -t auto /dev/block/bootdevice/by-name/product"$slot" /product
          mount -o ro -t auto /dev/block/bootdevice/by-name/persist"$slot" /persist) 2>/dev/null
          addToLog "- Device doesn't have dynamic partitions, mounting /system$slot as ro"
          mount -o ro -t auto /dev/block/bootdevice/by-name/system"$slot" /system_root
        fi
      else
         addToLog "- $ret should be equals to 0"
      fi
    ;;
  esac;
  addToLog "----------------------------------------------------------------------------"
  addToLog "- Checking if /system_root is mounted.."
  addToLog "----------------------------------------------------------------------------"
  if is_mounted /system_root; then
    mount_apex;
    if [ -f /system_root/build.prop ]; then
      addToLog "- Binding /system_root as /system"
      $BB mount -o bind /system_root /system;
    else
      addToLog "- Binding /system_root/system as /system"
      $BB mount -o bind /system_root/system /system;
    fi;
  elif is_mounted /system; then
    addToLog "- /system is mounted"
  else
    addToLog "- Could not mount /system"
    abort_while_mounting "- Could not mount /system, try changing recovery!"
  fi;
  addToLog "----------------------------------------------------------------------------"
  system=/system
  if [ -d /dev/block/mapper ]; then
    for block in system vendor product; do
      for slot in "" _a _b; do
        addToLog "- Executing blockdev setrw /dev/block/mapper/$block$slot"
        blockdev --setrw /dev/block/mapper/$block$slot 2>/dev/null
      done
    done
  addToLog "----------------------------------------------------------------------------"
  fi
  addToLog "- Remounting /system as read write"
  mount -o rw,remount -t auto /system || mount -o rw,remount -t auto /
  for partition in "vendor" "product"; do
    addToLog "- Remounting /$partition as read write"
    mount -o rw,remount -t auto "/$partition" 2>/dev/null
  done
  addToLog "----------------------------------------------------------------------------"
  ls -alR /system > "$COMMONDIR/System_Files_Before.txt"
  ls -alR /product > "$COMMONDIR/Product_Files_Before.txt"
}

# More info on Apex here -> https://www.xda-developers.com/android-q-apex-biggest-tdynamic_partitionshing-since-project-treble/
mount_apex() {
  [ -d /system_root/system/apex ] || return 1;
  local apex dest loop minorx num var;
  setup_mountpoint /apex;
  minorx=1;
  [ -e /dev/block/loop1 ] && minorx=$($BB ls -l /dev/block/loop1 | $BB awk '{ print $6 }');
  num=0;
  for apex in /system_root/system/apex/*; do
    dest=/apex/$($BB basename $apex .apex);
    case $dest in
      *.current|*.release) dest=$(echo $dest | $BB rev | $BB cut -d. -f2- | $BB rev);;
    esac;
    $BB mkdir -p $dest;
    case $apex in
      *.apex)
        $BB unzip -qo $apex apex_payload.img -d /apex;
        $BB mv -f /apex/apex_payload.img $dest.img;
        $BB mount -t ext4 -o ro,noatime $dest.img $dest 2>/dev/null;
        if [ $? != 0 ]; then
          while [ $num -lt 64 ]; do
            loop=/dev/block/loop$num;
            ($BB mknod $loop b 7 $((num * minorx));
            $BB losetup $loop $dest.img) 2>/dev/null;
            num=$((num + 1));
            $BB losetup $loop | $BB grep -q $dest.img && break;
          done;
          $BB mount -t ext4 -o ro,loop,noatime $loop $dest;
          if [ $? != 0 ]; then
            $BB losetup -d $loop 2>/dev/null;
          fi;
        fi;
      ;;
      *) $BB mount -o bind $apex $dest;;
    esac;
  done;
  for var in $($BB grep -o 'export .* /.*' /system_root/init.environ.rc | $BB awk '{ print $2 }'); do
    eval OLD_${var}=\$$var;
  done;
  $($BB grep -o 'export .* /.*' /system_root/init.environ.rc | $BB sed 's; /;=/;'); unset export;
}

restore_env() {
  $BOOTMODE && return 1;
  local dir;
  unset -f getprop;
  [ "$OLD_LD_PATH" ] && export LD_LIBRARY_PATH=$OLD_LD_PATH;
  [ "$OLD_LD_PRE" ] && export LD_PRELOAD=$OLD_LD_PRE;
  [ "$OLD_LD_CFG" ] && export LD_CONFIG_FILE=$OLD_LD_CFG;
  unset OLD_LD_PATH OLD_LD_PRE OLD_LD_CFG;
  umount_all;
  [ -L /etc_link ] && $BB rm -rf /etc/*;
  (for dir in /apex /system /system_root /etc; do
    if [ -L "${dir}_link" ]; then
      rmdir $dir;
      $BB mv -f ${dir}_link $dir;
    fi;
  done;
  $BB umount -l /dev/random) 2>/dev/null;
}

setup_env() {
  ui_print " "
  ui_print "--> Mounting partitions"
  mount_all;
  OLD_LD_PATH=$LD_LIBRARY_PATH;
  OLD_LD_PRE=$LD_PRELOAD;
  OLD_LD_CFG=$LD_CONFIG_FILE;
  unset LD_LIBRARY_PATH LD_PRELOAD LD_CONFIG_FILE;
  if [ ! "$(getprop 2>/dev/null)" ]; then
    getprop() {
      local propdir propfile propval;
      for propdir in / /system_root /system /vendor /odm /product; do
        for propfile in default.prop build.prop; do
          test "$propval" && break 2 || propval="$(file_getprop $propdir/$propfile "$1" 2>/dev/null)";
        done;
      done;
      test "$propval" && echo "$propval" || echo "";
    }
  elif [ ! "$(getprop ro.build.type 2>/dev/null)" ]; then
    getprop() {
      ($(which getprop) | $BB grep "$1" | $BB cut -d[ -f3 | $BB cut -d] -f1) 2>/dev/null;
    }
  fi;
}

# Unmount apex partition upon recovery cleanup
umount_apex() {
  [ -d /apex/com.android.runtime ] || return 1;
  local dest loop var;
  for var in $($BB grep -o 'export .* /.*' /system_root/init.environ.rc | $BB awk '{ print $2 }'); do
    if [ "$(eval echo \$OLD_$var)" ]; then
      eval $var=\$OLD_${var};
    else
      eval unset $var;
    fi;
    unset OLD_${var};
  done;
  for dest in $($BB find /apex -type d -mindepth 1 -maxdepth 1); do
    if [ -f $dest.img ]; then
      loop=$($BB mount | $BB grep $dest | $BB cut -d\  -f1);
    fi;
    ($BB umount -l $dest;
    $BB losetup -d $loop) 2>/dev/null;
  done;
  $BB rm -rf /apex 2>/dev/null;
}

setup_env
